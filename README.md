# AES_CBC-with-PyQt5
AES_CBC模式下的加解密过程（含PyQt5界面）

## 引入Cryptography加密算法库
使用命令pip install cryptography，下载Cryptography密码库。Cryptography是python语言中非常著名的加解密库，在算法层面提供了高层次的抽象，使用起来非常简单、直观，同时还保留了各种不同算法的低级别接口，保留灵活性。
Cryptography密码库实现了一个集成的对称密码函数，称为Fernet。它可以保证信息无法被篡改和破解。

## Fernet 说明
Fernet模块包括了对数据的加解密以及签名验证功能，以及密钥过期机制。

a)	加解密算法为AES，密钥位长256，前128位用于加密，后128位用于签名；
b)	采用CBC模式，填充标准PKCS7；
c)	签名算法为SHA256的HMAC；
d)	密钥可以设置过期时间。

## 密钥生成
密钥可以随机生成，也可以是用户自定义的。
随机生成密钥的函数为Fernet.generate_key()。其算法内核是os.urandom(n) 函数。
如果使用自定义的密钥，则需要调用PBKDF2函数处理密钥，它的基本原理是通过一个伪随机函数（本实验使用HMAC函数），把明文和一个盐值作为输入参数，然后重复进行运算，最终产生密钥。如果重复的次数足够大，破解的成本就会变得很高。而盐值的添加也会增加“彩虹表”攻击的难度。
用户自定义密钥后，需要设定PBKDF2算法的参数。


## 调用Fernet实现加密解密

### 初始化
使用密钥初始化Fernet，crypt = Fernet(key)。

### 加密
加密对应的方法是encrypt(data)，data为待加密字节串。加密时，首先获取当前系统时间，然后使用os.urandom(n)函数生成128位的初始向量，将当前系统时间和初始向量一起作为参数加密生成密文字节串。具体调用方式为cipher_text =  encrypt(data)。

### 解密
解密对应的方法是decrypt(data)，data为待解密字节串。解密时要检查数据格式是否为字节串，同时要检测过期时间TTL（TTL默认为None），还会将加密前填充的字符删去。具体调用方式为plain_text = crypt.decrypt(data)，由于解密后得到的数据格式仍为byte型字节串，因此要使用decode()函数将其转换为字符串。


## 设计UI界面
打开Qt Designer设计窗体。（可视化界面让UI设计方便很多）


## 将ui文件转换为py文件
窗体设计好后另存为文件AES.ui，需要使用PyUIC将.ui文件转化为py文件。打开命令行，输入pyuic5 -o D:\AES.py D:\AES.ui 回车.
其中，-o 后的第一个参数为输出文件的名称，第二个参数为ui文件的名称。
 
 
## 添加事件
最初生成的py文件只有关于窗体及窗体内各部件的描述。我们需要给各个按钮添加事件。Qt采用信号与槽机制，槽函数可以和一个信号相连接，当这个信号发生时，它就被自动调用。连接信号与槽的是connect()函数。调用方法为self.btnXXX.clicked.connect(self.XXX)。括号中的XXX函数是我们需要自主实现的，具体对应Fernet各部分功能。

## 写在最后
若加密后先关闭程序，然后重新运行程序进行解密，则会出现解密失败的情况，这是由于程序每次运行都会随机生成一个新的盐值（用于PBKDF2算法导出密钥）。因此，即使密钥不变，最后初始化的Fernet也会不同，因此无法得到解密结果。
Fernet使用PBKDF2算法处理密钥其实是基于安全性考虑的。如果每次哈希加密都使用相同的盐值，那么这样加盐的方式是做无用功，因为两个相同的密码会得到相同的哈希值。但是每次生成新的盐值的方法又对一些小型应用不够友好。针对这一问题的解决办法是储存每次加密的盐值，这种方法在服务端已经有类似的应用，但是随之又产生了一些新问题，比如保护盐值也要浪费一定的资源，同时也降低了整体的安全性。在一些不需要与服务端交互的本地应用上，只能将盐值硬编码到软件中。这也有一定的风险，因为攻击者可以专门为这个软件制作查询表和彩虹表，那么破解它生成的哈希值就变得很简单了。
